\section{Generación de bundles}
Para la generación de bundles se usaron diferentes algoritmos, cada uno con sus ventajas.\\
El algoritmo jerárquico \texttt{HAC} comienza con tantos clusters como cantidad de elementos, 
cada uno está conformado por un solo ítem y en cada paso une los dos clusters que maximizan su 
similitud y respeten las restricciones, que en estos casos fueron no superar los $5$ elementos por 
bundle.\\
El algoritmo \texttt{BOBO-x} genera los clusters a partir de un ítem, llamado pivote, y luego de 
forma golosa selecciona los ítems que maximizan la función intra-cluster. La $x$ representa el 
número de bundles que va a generar\\
El algoritmo \texttt{BOBO-Ex} es similar a \texttt{BOBO-x} pero prueba con todos los ítems como 
pivots para la generación de bundles.
\section{Selección de bundles}
Se utilizaron tres estrategias de selección de bundles para generar las soluciones finales.
\subsection{Selección golosa}
Para la selección de los bundles se utilizó un algoritmo goloso que comienza seleccionando el 
cluster con mayor valor intra y en cada iteración se elige el cluster que maximiza la función 
objetivo.\\
Durante las primeras pruebas notamos que todas las soluciones contenían varios bundles en común 
teniendo en cuenta que se utilizaron distintos valores gammas. Supusimos que esto se debía a que en 
el momento de hacer la selección en todos los casos, sin importar el gamma, se seleccionaba el mismo 
bundle (que es el de mayor intra). Al siguiente paso al seleccionar el bundle que maximiza la 
función objetivo, ocurre que el valor intra del bundle es mucho más significativo que el inter. Por 
lo tanto, lo que ocurre es que en los primeros pasos se seleccionan los mismos bundles para todos 
los gammas sin tener en cuenta que cuando se optó por un gamma cercano a cero se pedía que la 
solución sea más diversificada.\\
\subsection{Selección de a pares}
Para mejorar el proceso de selección se decidió modificar el algoritmo para que en vez de realizar 
la selección de a un bundle, se generan pares de bundles y el algoritmo goloso selecciona el que 
maximiza la función objetivo.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\REQUIRE Aca va la entrada del algoritmo.
\ENSURE Aca va la salida del algoritmo.
\WHILE {alguna conodicion}
\STATE Descripcion con palabras.
\IF{alguna conodicion copada} \label{lin:marcacionLinea}
\RETURN devuelve algo
\ELSE
\STATE alguna asignacion o algo
\ENDIF
\ENDWHILE
\FOR{alguna otra condicion}
\IF{alguna conodicion}
\STATE hace algo
\RETURN devuelve algo
\ENDIF
\ENDFOR
\RETURN devuelve otra cosa
\end{algorithmic}
\caption{Selección de bundles de a pares}\label{alg:algSelTuple}
\end{algorithm}
%El algoritmo~\ref{alg:algSelTuple} es bastante raro, hago referencia a la~\ref{lin:marcacionLinea}
\subsection{Selección proporcional}
Además como tercera opción de selección se implementó un algoritmo proporcional que en cada paso se 
ponderan los resultados de la función que calcula el intra y el inter restante, intentando 
\textquotedblleft adivinar \textquotedblright el valor de las próximas iteraciones y de esta manera 
dar más importancia en los primeras iteraciones al valor del inter.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\REQUIRE Aca va la entrada del algoritmo.
\ENSURE Aca va la salida del algoritmo.
\WHILE {alguna conodicion}
\STATE Descripcion con palabras.
\IF{alguna conodicion copada}
\RETURN devuelve algo
\ELSE
\STATE alguna asignacion o algo
\ENDIF
\ENDWHILE
\FOR{alguna otra condicion}
\IF{alguna conodicion}
\STATE hace algo
\RETURN devuelve algo
\ENDIF
\ENDFOR
\RETURN devuelve otra cosa
\end{algorithmic}
\caption{Selección de bundles proporcional}\label{alg:algSelProp}
\end{algorithm}

\section{Modificación de PAC para búsquedas específicas}
Para la obtención de la solución se modificó la producción de bundles como así también la 
selección de los mismos (Produce and Choose). \\
En la producción de bundles en el algoritmo jerárquico, se utilizó la similitud del perfil 
específico con los papers en cada paso que intenta unificar dos clusters. A diferencia del cálculo 
original que la compatibilidad de dos nodos esta dada por su distancia previamente obtenida, en 
este nuevo caso se agrega a ese resultado la compatibilidad de cada uno de ellos con el perfil 
específico. \\
Para la producción del algoritmo BOBO, se agregó junto al pivote en todos los clusters. \\
Para la selección de los bundles que formarán parte de la solución, a cada cluster se le 
calculo el valor intra también se tuvo en cuenta la similitud de todos los elmentos con el perfil  
específico, de esta manera a los clusters que contenían papers con los mismos tópicos que el del 
vector especifico se le dio mayor peso.
