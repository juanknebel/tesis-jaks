\section{Related Work}
\texttt{Composite Retrieval of Diverse and Complementary Bundles} es el artículo que propone esta forma de devolver los resultados. En el mismo sugieren distintos algoritmos para hallar una solución entre ellos se encuentra Produce and Choose que consiste en una primer fase de generar bundles y en la siguiente fase seleccionar los bundles de la solución. En el artículo para la fase de producción uno de los algoritmos que se utiliza es de clusterización jerárquico, más adelante se explicara con más detalle.
\subsection{Data Model}
Dado el conjunto de objetos $I$ y una función de similitud $ s: I \times I \rightarrow [0;1]$, cada objeto es unívocamente identificado y contiene un conjunto de atributos. La entrada puede pensarse como un grafo completo con peso en las aristas $G=(I,E,s)$ donde el peso del vértice $(u,v)$ es $s(u,v)$. Se define también la \textit{función de distancia} $d(u,v) = 1 - s(u,v)$ que también toma valores en el intervalo $[0;1]$.
\subsection{Problem Statement}
El problema consiste en devolver un conjunto de bundles $S = \left\{s_1, \ldots, s_k\right\}$ donde el bundle $S_i \in 2^{I}$ es un conjunto de objetos que satisface las reglas de \textit{complementaridad} que no permite que existen dos objetos con igual atributo en el mismo bundle y de \textit{presupuesto} para que la suma de los costos de los objetos no exceda el presupuesto dado.\\
\textbf{Definición} Dado el conjunto de objetos $I=\left\{i_1,\ldots, i_n\right\}$ el bundle $S \in 2^{I}$ es válido si y sólo si satisface las reglas:
\begin{itemize}
	\item \textbf{Complementaridad:} dada la propiedad $\alpha$ de los objetos, $\forall u,v \in S_i, u.\alpha \neq v.\alpha$
	\item \textbf{Presupuesto:} dada la función de costo $f$ y el presupuesto $\beta$, entonces $\forall S_i \in S, f(S_i) \leq \beta$
\end{itemize}

La definición formal de \textit{Composite Retrieval} es:\\
Dado el conjunto de objetos $I = \left\{i_1, \ldots, i_n \right\}$, la función de similitud $s(u,v)$, el atributo complementario $\alpha$, la función de costo $f$, el presupuesto $\beta$ y el entero $k$ se desea hallar el conjunto válido de bundles $S = \left\{s_1, \ldots, s_k\right\}$ que maximiza la función:
\begin{equation} \label{des:eq-fnObj}
  \sum_{1 \leq i \leq k}{\sum_{u,v \in S_i}{\gamma s(u,v)}} + \sum_{1 \leq i \leq j \leq k}{(1-\gamma) (1-\max_{u \in S_i, v \in S_j}{s(u,v)})}
\end{equation}
Esta es una tipia función objetivo de un problema de clustering, donde la calidad del clustering es una combinación entre la calidad de cada cluster (intra-cluster) y de la separación entre clusters (inter-cluster). A través del parámetro $\gamma$ el usuario puede definir el balance entre intra e inter de una solución. Si El usuario prioriza una solución de bundles cohesivos sobre la diversidad el  valor de $\gamma$ será cerca de uno y si lo que prioriza es la diversidad el valor estará cerca del cero.\\
En \cite{compositeRetrival} se demuestra que la complejidad de devolver $k$ bundles de items complementarios con un presupuesto es NP-Completo, por el momento no se puede encontrar una solución exacta en tiempo polinomial, por lo cual este trabajo se enfoca a encontrar soluciones suficientemente buenas para el problema. Para poder encontrar la mejor solución se implementaron dos algoritmos para poder comparar los resultados: Produce-and-Choose y algoritmo goloso.
\subsection{Problem Complexity}
La complejidad del problema
\section{Produce and Choose}
Explicar el algoritmo produce and choose y que para el produce se utilizo el Hierichal
\section{Proposal}
Sobre el trabajo de 1 se realizaron las siguientes propuestas con los objetivos 1) realizar las búsquedas en instancias más grandes y 2)heuristicas que mejoren el resultado obtenido.\\
Para 1) se realizo una variante del algoritmo jerárquico que reduce el orden de complejidad. 
Para 2) se propusieron dos implementaciones de la metahuristica tabu search para encontrar mejores soluciones en cada una de las etapas de PAC.

\subsection{Produce Phase}
La clusterización jerárquica se clasifica entre los algoritmos \textit{aglomerativo} y \textit{divisivo}. En el aglomerativo inicialmente cada objeto pertenece a un cluster unitario y luego sucesivamente se unen un par de clusters hasta que todos los clusters se hayan unido en un único cluster que contenga a todos los objetos, esete algoritmo es conocido como \textit{hierarchical agglomerative clustering} (HAC). El divisorio comienza con un único cluster al que todos los objetos pertenecen y recursivamente se realiza una división del cluster hasta obtener clusters con un solo objeto.\\
\textit{Constrained hierarchical agglomerative clustering} (C-HAC) es una modificación que se realiza sobre HAC para que nunca se realice la unión de los clusters $S_1$ y $S_2$ si el cluster resultante $S_1 \cup S_2$ es inválido, o sea sí el cluster resultante no cumple con las restricciones de similitud o el costo del bundle supera el presupuesto. El algoritmo C-HAC que se presenta a continuación, en este trabajo se denomina \texttt{Simple C-HAC}, es el que se propone en \cite{compositeRetrival}.\\

\begin{algorithm}[H]
\begin{algorithmic}[1]
\REQUIRE {$I,\alpha,f,\beta,\gamma,\text{ cantidad de bundles }c$}
\ENSURE Conjunto válido de bundles
\STATE $cand \leftarrow \bigcup_{i \in I}\left\{i\right\}$
\WHILE {$ \left|cand\right| > c$}
	\STATE $bestScore \leftarrow -\infty$
	\STATE $bestCandidate \leftarrow \emptyset$
	\FOR{$\text{each}\ S_i\in cand$}
		\FOR{$\text{each}\ S_j\in cand; S_i \neq S_j$}
			\IF {$ValidMerge(S_i,S_j,\alpha,f,\beta)$} \label{validMerge}
				\IF {$Score(S_i \cup S_j) \geq bestcore$} \label{score}
					\STATE $bestScore \leftarrow score(S_i \cup  S_j)$
					\STATE $bestCandidate \leftarrow \left\{S_i,S_j\right\}$
				\ENDIF
			\ENDIF
		\ENDFOR
	\ENDFOR
	\IF {$bestCandidate = \emptyset$}
		\BREAK
	\ENDIF
	\STATE {$cand \leftarrow cand \setminus \left\{S\right\}$ $(\forall S \in bestCandidate)$}
	\STATE $cand \leftarrow cand \cup bestCandidate $
\ENDWHILE
\RETURN $cand$
\end{algorithmic}
\caption{Simple C-HAC}\label{alg:SimpleC-HAC}
\end{algorithm}

El algoritmo ejecuta $N - c$ pasos donde se unen los dos clusters más similares que forman un cluster válido. En cada paso se realiza una comparación entre todos los clusters. Por lo tanto el orden de complejidad de \texttt{Simple C-HAC} es $\mathcal{O}(N^{3})$.\\

En cada iteración se unen los dos clusters que maximizan la función \textit{Score}. El artículo \cite{compositeRetrival} proponé que \textit{Score} se calcule sumarizando la similitud entre todos los objetos del cluster candidato. Este criterio de unión es local, ya que presta atención unicamente a la similitud inter cluster. Por lo que se propuso un criterio que tenga en cuenta toda la estructura del clustering al momento de decidir la unión de los clusters. La función que se propone es \textit{Sim} que sumariza la similitud entre todos los elementos de la unión de los clusters y se le suma la similitud de los dos elementos más disimiles proporcionando el peso con el valor de $\gamma$ entre la similitud y el disímil.\\

Por el orden de complejidad del algoritmo \texttt{Simple C-HAC}  en escenarios donde la clusterización se tenga que hacer entre miles de objetos el tiempo de ejecución será tan elevado que el algoritmo es improductivo. Para contemplar estos escenarios se implemento el algoritmo \texttt{Efficient C-HAC} que la complejidad es $\mathcal{O}(N^{2}\lg n)$. La similitud entre los clusters se guarda en colas de prioridad en orden decreciente, entonces la cola $P\left[k\right].max()$ devuelve el cluster de mayor similitud con el k-ésimo cluster. Luego de combinar los clusters $\omega_{k_{1}}$ y $\omega_{k_{2}}$, $\omega_{k_{1}}$ se utiliza como la representación. Para $\omega_{k_{1}}$ se calcula la similitud con el resto de los clusters y se actualiza en las colas de similitud. Para identificar entre dos cluster que la unión es invalida por alguna de las restricciones, en las colas de similitud el valor de la similitud es $-1$.\\

\begin{algorithm}[H]
\begin{algorithmic}[1]
\REQUIRE {$I,\alpha,f,\beta,\gamma$}
\ENSURE Conjunto válido de bundles
\FOR{$\text{each}\ S_i\in I$}
	\FOR{$\text{each}\ S_j\in I$}
		\IF {$validMerge(S_i,S_j,\alpha,f,\beta)$} 
			\STATE $C[i][j].sim \leftarrow Score(S_i \cup S_j)$
		\ELSE
			\STATE $C[i][j].sim \leftarrow -1$
		\ENDIF
		\STATE $C[i][j].index \leftarrow j$
	\ENDFOR
	\STATE $I[i] \leftarrow 1$
	\STATE {$P[i] \leftarrow $ priority queue for $C[i]$ sorted on sim}
	\STATE {P[i].Delete(C[i][i]) (se elimina así mismo de la pila)}
\ENDFOR
\STATE $A \leftarrow []$
\FOR {$k \leftarrow 1$ to $I.length$}
	\STATE $k_1 \leftarrow \max_{k:I[k]=1}{P[k].max().sim}$
	\IF {$validMerge(S_i,S_j,\alpha,f,\beta)$}
		\BREAK
	\ENDIF
	\STATE $k_2 \leftarrow P[k_1].max().index$
	\STATE $A.Append(\left\langle k_1,k_2 \right\rangle)$
	\STATE $I[k_2] \leftarrow 0$
	\STATE $P[k_1] \leftarrow []$
	\FOR {$i$ with $I[i]-1 \vee i \neq k_1$}
		\STATE $P[i].Delete(C[i][K_1])$
		\STATE $P[i].Delete(C[i][k_2])$
		\IF {$validMerge(S_i,S_j,\alpha,f,\beta)$}
			\STATE $C[i][k_1].sim \leftarrow Sim(i,k_1 \cup k_2,\gamma)$
			\STATE $C[k_1][i].sim \leftarrow Sim(i,k_1 \cup k_2,\gamma)$
		\ELSE
			\STATE $C[i][k_1].sim \leftarrow -1$
			\STATE $C[k_1][i].sim \leftarrow -1$
		\ENDIF
		\STATE $C[i][k_1].index \leftarrow i$
		\STATE $C[k_1][i].index \leftarrow i$		
		\STATE $P[i].Insert(C[i][k_1])$
		\STATE $P[K_1].Insert(C[k_1][i])$		
	\ENDFOR
\ENDFOR

\RETURN $A$
\end{algorithmic}
\caption{Efficient C-HAC}\label{alg:Efficient C-HAC}
\end{algorithm}

\subsection{Tabu search}
Las búsquedas locales consisten en moverse de solución en solución, aplicando cambios a la solución candidata hasta encontrar una mejor solución o satisfacer un criterio de parada. Los algoritmos consisten en comenzar con una solución e iterativamente moverse a una solución vecina, esto es posible solo si se pude definir una relación de vecindad en el espacio de búsqueda. Como una solución puede tener muchas soluciones vecinas se elige siempre la que maximice o minimice (según el problema elegido) el criterio seleccionado, esto produce que el algoritmo pueda estancarse en un mínimo (ó máximo) local y nunca pueda salir de él.\\
\textbf{Tabú search} es una metaheurística, de la familia de las búsquedas locales, que relaja la primer regla de las búsquedas locales tradicionales y permite moverse a una solución vecina que no cumple con el criterio de búsqueda. De esta manera se permite al algoritmo escapar de máximos o mínimos locales y encontrar una mejor solución (en caso que existiese). Otras de las modificaciones que se agregan es que una vez que una solución determinada es visitada, se la marca como tabú para que no vuelva a ser visitada por una determinada cantidad de iteraciones para también de esta manera evitar caer en ciclos y mínimos o máximos locales.\\
Una de las ventajas que tienen este tipo de metaheurísticas es que no son muy costosas en tiempo de ejecución siempre que la cantidad máxima de iteraciones no sea excesiva, con lo cual se puede ejecutar sin problemas y sin importar el algoritmo de generación y selección provenga la solución orginal con el fin de intentar mejorarla.\\
Se implementaron las búsquedas tabú Inter-Bundle e Intra-Bundle. La primera busca encontrar una mejor solución entre la solución actual y los bundles ya generados; la otra consiste en mejorar los bundles con los items que quedaron fuera de la solución.

\subsection{Inter-Bundle}
La búsqueda se concibió especialmente para la fase de selección del algoritmo \texttt{Produce and Choose} que es la fase en la que se selecciona un subconjunto de bundles del conjunto de bundles generados en la fase anterior. De la solución obtenida en la fase de selección se realiza la búsqueda tabú con los bundles generados en la fase del produce con el objetivo de visitar las soluciones vecinas.\\
Los movimientos de la solución $S$ a la solución $S'$ consiste de los siguientes  pasos:
\begin{enumerate}
	\item Quitar de la solución el bundle con menor Inter.
	\item Determinar el bundle centroide de la solución.
	\item Calcular la función objetivo agregando uno de los $K$ bundles generados más lejos del centroide.
	\item Quedarse con la solución con mayor función objetivo. 
\end{enumerate}

Sea $S$ el conjunto de bundles de la solucion y B el conjunto de todos los bundles producidos. El bundle (1) es el más acoplado al de la solución $b_r = \min_{b_1 \in S}{\sum_{b_2 \in S}{\psi(b_1,b_2)}}$. El centroide de (2) es el bundle que tiene mayor similitud entre los bundles de la solución, sin tener en cuenta al bundle a reemplazar, entonces el centroide es:
$$b_c = \min_{b_1 \in S \setminus \left\{b_r\right\}}{\sum_{b_2 \in S \setminus \left\{b_r\right\}}{\psi(b_1,b_2)}}$$
El bundle de (3) se obtiene de $b_n = \min_{b_1 \in S \setminus \left\{b_r\right\}}{\psi(b_1,b_c)}$. Por lo tanto la nueva solución es $S' = (S \setminus \left\{b_r\right\}) \cup \left\{b_n\right\}$. Mientras que el bundle $b_r$ se marca para que no sea seleccionado para las próximas soluciones generadas.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\REQUIRE {$S\text{ solucion},cand\text{ conjunto valido de bundles},\gamma, MAX\_SOL\text{ cantidad de soluciones vecinas visitadas},MAX\_BUND\text{ cantidad bundles para probar}, ITER\_TABU\text{ iteraciones en tabú}$}
\ENSURE Conjunto válido de bundles
\STATE $\omega(S) = \sum_{b \in S}{\sum_{u,v \in b}{\gamma s(u,v)}} + \sum_{b_1,b_2 \in S}{(1-\gamma) (1-\max_{u \in b_1, v \in b_2}{s(u,v)})}$
\STATE $UpdateTabu(S) = \left\{ \left\langle b, n-1 \right\rangle  / \left\langle b, n \right\rangle \in S \wedge n-1 > 0 \right\}$
\STATE $Inter(b_1, S) = \sum_{b_2 \in S, b_1\neq b_2}{(1-\max_{u \in b_1, v \in b_2}{s(u,v)})}$
\STATE $iteration \leftarrow 0$
\STATE $tabuBundles \leftarrow \emptyset$
\STATE $bestSolution \leftarrow S$
\STATE $visitSolution \leftarrow S$
\STATE $thresholdScore \leftarrow -\infty$ 
\WHILE {$iteration < MAX\_ITER$}
  \STATE $worstBundle \leftarrow \min_{b \in visitSolution \setminus tabuBundles}{Inter(b, visitSolution)}$
	\STATE $centroidBundle \leftarrow getCentroid(visitSolution)$
	\STATE $bestBundles \leftarrow \text{fetch first MAX\_BUND} \max_{b \in cand \setminus tabuBundles}{Dist(b, centroidBundle)}$
	\STATE $scoreInter \leftarrow \sum_{b \in visitSolution}{Inter(b, iterationSolution)}$
	\FOR {$\text{each}\ aBundle \in bestBundles$}
    \STATE $iterationSolution \leftarrow (visitSolution \setminus \left\{worstBundle\right\}) \cup \left\{aBundle\right\}$
    \STATE $newScoreInter \leftarrow \sum_{b \in iterationSolution}{Inter(b, iterationSolution)}$
    \IF {$newScoreInter > scoreInter$}
			\STATE $thresholdScore \leftarrow scoreInter$
      \STATE $scoreInter \leftarrow newScoreInter$
      \STATE $visitSolution \leftarrow iterationSolution$
    \ELSE
      \IF {$newScoreInter > thresholdScore$}
        \STATE $thresholdScore \leftarrow newScoreInter$
        \STATE $visitSolution \leftarrow iterationSolution$
      \ENDIF
    \ENDIF
  \ENDFOR
  \IF {$\omega(iterationSolution) > \omega(bestSolution)$}
    \STATE $bestSolution \leftarrow iterationSolution$
  \ENDIF
  \STATE $tabuBundles \leftarrow tabuBundles \cup \left\{
	\left\langle worstBundle, ITER\_TABU \right\rangle\right\}$
	\STATE $tabuBundles \leftarrow UpdateTabu(tabuBundles)$
	\STATE $iteration \leftarrow iteration + 1$
\ENDWHILE
\RETURN $bestSolution$
\end{algorithmic}
\caption{Búsqueda tabú sobre bundles}\label{alg:algBusTabuBundle}
\end{algorithm}

\subsection{Intra-Bundle}
En Intra-Bundle explora soluciones con bundles más cohesivos. De la solución actual se realiza el movimiento a una nueva solución con los pasos:
\begin{enumerate}
	\item Obtener el bundle menos cohesivos de la solución.
	\item Determinar el centroide del bundle.
	\item Hallar el ítem más alejado del centroide.
	\item Calcular el inter del bundle agregando uno de los $K$ items más cercano del centroide.
	\item Generar un nuevo bundle en la solución con el item que maximiza el inter.
\end{enumerate}

Sea $S$ el conjunto de bundles de la solución e $I$ el conjunto de ítems, el bundle de (1) es $b = \min_{b_1 \in S}{\sum_{v,w \in b_1}{s(v,w)}}$. De $b$ se define el centroide $c$ del paso (2) con $c = \max_{v \in b}{\sum_{w \in b}{s(v,w)}}$. El item de (3) se obtiene de $i = \min_{v \in b}{s(v,c)}$. El item para reemplazar a $i$ es $j = \max_{v \in I \setminus items(S)}{s(v,c)}$. Por lo que la nueva solución se define $S' = (S \setminus \left\{b\right\}) \cup \left\{(b \setminus \left\{i\right\})\cup\left\{j\right\}\right\}$

\begin{algorithm}[H]
\begin{algorithmic}[1]
\REQUIRE {$S\text{ solucion},cand\text{ conjunto valido de bundles},I,\alpha,f,\beta,k,\gamma, MAX\_SOL\text{ cantidad de soluciones vecinas visitadas},MAX\_BUND\text{ cantidad bundles para probar}, ITER\_TABU\text{ iteraciones en tabú}$}
\ENSURE Conjunto válido de bundles
\STATE $\omega(S) = \sum_{b \in S}{\sum_{u,v \in b}{\gamma s(u,v)}} + \sum_{b_1,b_2 \in S}{(1-\gamma) (1-\max_{u \in b_1, v \in b_2}{s(u,v)})}$
\STATE $Inter(b_1, S) = \sum_{b_2 \in S, b_1\neq b_2}{(1-\max_{u \in b_1, v \in b_2}{s(u,v)})}$
\STATE $Intra(b) = \sum_{u,v \in b}{\gamma s(u,v)}$
\STATE $UpdateTabu(S) = \left\{ \left\langle b, n-1 \right\rangle  / \left\langle b, n \right\rangle \in S \wedge n-1 > 0 \right\}$
\STATE $iteration \leftarrow 0$
\STATE $tabuBundles \leftarrow \emptyset$
\STATE $tabuElements \leftarrow \emptyset$
\STATE $bestSolution \leftarrow S$
\STATE $visitSolution \leftarrow S$
\STATE $thresholdScore \leftarrow -\inf$
\WHILE {$iteration < MAX\_ITER$}
  \STATE $worstBunlde \leftarrow \min_{b \in visitSolution \setminus tabuBundles}{Intra(b)}$
  \STATE $centroid \leftarrow GetCentroid(worstBunlde)$
  \STATE $faraway \leftarrow GetFarawayElement(worstBunlde,centroid)$
  \STATE $bestElements: \leftarrow \text{fetch first MAX\_BUND} \max_{b \in I \setminus tabuElements}{Dist(b, centroidBundle)}$
	\STATE $scoreInter \leftarrow \omega(visitSolution)$
  \FOR {$near \in bestElements$}
		\STATE $newBundle \leftarrow (worstBunlde \setminus \left\{faraway\right\})\cup\left\{near\right\}$
		\STATE $itSolution \leftarrow (visitSolution \setminus \left\{worstBunlde\right\}) \cup \left\{newBundle\right\}$
    \STATE $newScore \Leftarrow \omega(itSolution)$
		\IF {$newScore > scoreInter$}
			\STATE $thresholdScore \leftarrow scoreInter$
			\STATE $scoreInter \leftarrow newScore$
			\STATE $visitSolution \leftarrow itSolution$
    \ELSIF {$newScore > thresholdScore$}
				\STATE $thresholdScore \leftarrow newScore$
				\STATE $visitSolution \leftarrow itSolution$
    \ENDIF
  \ENDFOR
  \IF {$\omega(visitSolution) > \omega(bestSolution)$}
		\STATE $bestSolution \leftarrow visitSolution$
  \ENDIF
	\STATE $tabuBundles \leftarrow tabuBundles \cup \left\{
	\left\langle worstBunlde, ITER\_TABU \right\rangle\right\}$
  \STATE $tabuElements \leftarrow tabuElements \cup \left\{
	\left\langle faraway, ITER\_TABU \right\rangle\right\}$
	\STATE $tabuBundles \leftarrow UpdateTabu(tabuBundles)$
  \STATE $tabuElements \leftarrow UpdateTabu(tabuElements)$
	\STATE $iteration \leftarrow iteration + 1$
\ENDWHILE
\RETURN $bestSolution$
\end{algorithmic}
\caption{Búsqueda tabú sobre elementos}\label{alg:algBusTabuIntra}
\end{algorithm}
